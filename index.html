<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Badminton sim</title>
  <style>
    :root{
      --bg:#0f1418;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.04);
      --stroke: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --accent: rgba(140, 210, 255, .92);
      --good: rgba(120, 220, 160, .88);
      --bad: rgba(255, 150, 150, .88);
      --shadow: rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1100px 700px at 30% 10%, rgba(140,210,255,.10), transparent 55%),
                  radial-gradient(900px 600px at 75% 30%, rgba(120,220,160,.06), transparent 60%),
                  linear-gradient(180deg, #0b1013, var(--bg));
      color:var(--text);
      overflow:hidden;
    }
    #app{height:100%; display:flex; flex-direction:column;}
    header{
      padding:14px 14px 10px;
      display:flex; gap:12px; align-items:flex-end; justify-content:space-between;
      z-index:3; position:relative;
    }
    .title h1{margin:0; font-size:16px; font-weight:650; letter-spacing:.2px}
    .title p{margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.35; max-width:620px}

    .panel{
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid var(--stroke);
      border-radius:14px;
      box-shadow: 0 14px 45px var(--shadow), inset 0 1px 0 rgba(255,255,255,.06);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .controls{
      width:min(560px, calc(100vw - 28px));
      padding:12px 12px 10px;
    }
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    .slot{
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.12);
    }
    .slot h3{
      margin:0 0 8px;
      font-size:12px;
      font-weight:650;
      color: rgba(255,255,255,.86);
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .badge{
      font-size:11px;
      color: rgba(255,255,255,.75);
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
      user-select:none;
      white-space:nowrap;
    }
    .row{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin:8px 0;}
    label{display:flex; flex-direction:column; gap:4px; font-size:12px; color:var(--muted);}

    input[type="range"]{width:100%; appearance:none; height:18px; background: transparent; outline:none;}
    input[type="range"]::-webkit-slider-runnable-track{
      height:8px; border-radius:999px;
      background: linear-gradient(90deg, rgba(140,210,255,.22), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    input[type="range"]::-webkit-slider-thumb{
      appearance:none; width:18px; height:18px; border-radius:50%; margin-top:-6px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.92), rgba(140,210,255,.55));
      border:1px solid rgba(255,255,255,.25);
      box-shadow: 0 8px 20px rgba(0,0,0,.35), 0 0 0 4px rgba(140,210,255,.10);
    }
    input[type="range"]::-moz-range-track{
      height:8px; border-radius:999px;
      background: linear-gradient(90deg, rgba(140,210,255,.22), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.08);
    }
    input[type="range"]::-moz-range-thumb{
      width:18px; height:18px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.92), rgba(140,210,255,.55));
      border:1px solid rgba(255,255,255,.25);
      box-shadow: 0 8px 20px rgba(0,0,0,.35), 0 0 0 4px rgba(140,210,255,.10);
    }

    .val{
      min-width:56px;
      text-align:right;
      font-size:12px;
      font-variant-numeric: tabular-nums;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.10);
      color: rgba(255,255,255,.84);
      user-select:none;
    }

    .buttons{display:flex; gap:10px; margin-top:10px;}
    button{
      flex:1;
      cursor:pointer;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.90);
      padding:10px 10px;
      font-size:12px;
      letter-spacing:.2px;
      box-shadow: 0 10px 28px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.06);
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    button:hover{ background: rgba(255,255,255,.06); border-color: rgba(140,210,255,.22); }
    button:active{ transform: translateY(1px); }

    main{
      position:relative;
      flex:1;
      padding: 0 14px 14px;
      display:grid;
      grid-template-rows: 1fr auto;
      gap:12px;
      z-index:2;
      min-height:0;
    }

    .stage{
      position:relative;
      overflow:hidden;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 14px 60px rgba(0,0,0,.35);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.08));
      min-height: 360px;
    }
    canvas{position:absolute; inset:0; width:100%; height:100%;}
    .overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(900px 500px at 50% -10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(900px 600px at 50% 120%, rgba(0,0,0,.40), transparent 65%),
        radial-gradient(1200px 900px at 50% 50%, transparent 60%, rgba(0,0,0,.35));
      opacity:.95;
      mix-blend-mode: screen;
    }

    .scoreOverlay{
      position:absolute;
      left:12px; right:12px; top:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index:5;
      box-shadow: 0 14px 45px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
      user-select:none;
    }
    .team{
      display:flex;
      align-items:baseline;
      gap:10px;
      min-width:140px;
    }
    .team .name{
      font-size:12px;
      color: rgba(255,255,255,.75);
      letter-spacing:.2px;
    }
    .team .score{
      font-size:20px;
      font-weight:750;
      font-variant-numeric: tabular-nums;
      letter-spacing:.4px;
    }
    .serveDot{
      width:10px; height:10px; border-radius:50%;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 4px rgba(140,210,255,.10);
      background: rgba(255,255,255,.25);
      margin-left:6px;
    }
    .serveDot.on{ background: rgba(140,210,255,.85); }

    .midInfo{
      text-align:center;
      flex:1;
      min-width:120px;
    }
    .midInfo .small{font-size:11px; color: var(--muted)}
    .midInfo .big{font-size:12px; margin-top:4px; color: rgba(255,255,255,.86)}

    .bottom{
      display:grid;
      grid-template-columns: 1.3fr 1fr;
      gap:12px;
      min-height:0;
    }
    .cards{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; padding:10px;}
    .card{
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.12);
    }
    .card .k{font-size:11px; color:var(--muted); margin-bottom:6px;}
    .card .v{font-size:14px; font-variant-numeric: tabular-nums; letter-spacing:.2px;}
    .bar{
      height:8px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      overflow:hidden;
      margin-top:8px;
    }
    .bar > i{display:block; height:100%; width:50%; background: linear-gradient(90deg, rgba(140,210,255,.65), rgba(120,220,160,.55));}

    .log{
      padding:10px 12px;
      overflow:auto;
      font-size:12px;
      line-height:1.35;
      color: rgba(255,255,255,.84);
      min-height:0;
    }
    .log .muted{color:var(--muted)}
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      margin-right:6px;
      font-size:11px;
      color: rgba(255,255,255,.78);
    }
    .pill.good{border-color: rgba(120,220,160,.25); color: rgba(120,220,160,.88);}
    .pill.bad{border-color: rgba(255,150,150,.25); color: rgba(255,150,150,.88);}

    @media (max-width: 980px){
      header{flex-direction:column; align-items:stretch;}
      .grid{grid-template-columns:1fr;}
      main{grid-template-rows: 1fr auto;}
      .bottom{grid-template-columns: 1fr; }
      .cards{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">
      <h1>Badminton sim</h1>
      <p>Single match simulator (singles). Skills drive rally outcomes. Real rules: first to 21, win by 2, cap at 30. Serve stays with the rally winner.</p>
    </div>

    <div class="panel controls" role="region" aria-label="Controls">
      <div class="grid">
        <div class="slot">
          <h3>Player A <span class="badge" id="aBadge">bottom court</span></h3>
          <div class="row">
            <label>Speed
              <input id="aSpeed" type="range" min="0" max="100" step="1" value="65">
            </label>
            <div class="val" id="aSpeedVal">65</div>
          </div>
          <div class="row">
            <label>Smash power
              <input id="aSmash" type="range" min="0" max="100" step="1" value="62">
            </label>
            <div class="val" id="aSmashVal">62</div>
          </div>
          <div class="row">
            <label>Intelligence
              <input id="aIQ" type="range" min="0" max="100" step="1" value="58">
            </label>
            <div class="val" id="aIQVal">58</div>
          </div>
        </div>

        <div class="slot">
          <h3>Player B <span class="badge" id="bBadge">top court</span></h3>
          <div class="row">
            <label>Speed
              <input id="bSpeed" type="range" min="0" max="100" step="1" value="60">
            </label>
            <div class="val" id="bSpeedVal">60</div>
          </div>
          <div class="row">
            <label>Smash power
              <input id="bSmash" type="range" min="0" max="100" step="1" value="66">
            </label>
            <div class="val" id="bSmashVal">66</div>
          </div>
          <div class="row">
            <label>Intelligence
              <input id="bIQ" type="range" min="0" max="100" step="1" value="55">
            </label>
            <div class="val" id="bIQVal">55</div>
          </div>
        </div>
      </div>

      <div class="buttons">
        <button id="play">Play rally</button>
        <button id="auto">Auto (10 rallies)</button>
        <button id="reset">Reset game</button>
      </div>
    </div>
  </header>

  <main>
    <div class="stage panel">
      <div class="scoreOverlay" aria-label="Scoreboard">
        <div class="team" aria-label="Player A score">
          <div class="name">Player A <span class="serveDot" id="serveA" title="Serving"></span></div>
          <div class="score" id="scoreA">0</div>
        </div>

        <div class="midInfo">
          <div class="small" id="ruleLine">Game to 21 • win by 2 • cap 30</div>
          <div class="big" id="statusLine">Ready</div>
        </div>

        <div class="team" style="justify-content:flex-end;" aria-label="Player B score">
          <div class="score" id="scoreB">0</div>
          <div class="name"><span class="serveDot" id="serveB" title="Serving"></span> Player B</div>
        </div>
      </div>

      <canvas id="cv"></canvas>
      <div class="overlay"></div>
    </div>

    <div class="bottom">
      <div class="panel">
        <div class="cards">
          <div class="card">
            <div class="k">Win chance (next rally)</div>
            <div class="v"><span id="chanceA">50</span>% / <span id="chanceB">50</span>%</div>
            <div class="bar" aria-hidden="true"><i id="chanceBar"></i></div>
          </div>
          <div class="card">
            <div class="k">Rally length (last)</div>
            <div class="v" id="rallyLen">—</div>
            <div class="k" style="margin-top:8px;">Shot that ended rally</div>
            <div class="v" id="endShot">—</div>
          </div>
          <div class="card">
            <div class="k">Result (last)</div>
            <div class="v" id="lastPoint">—</div>
            <div class="k" style="margin-top:8px;">Reason</div>
            <div class="v" id="reason">—</div>
          </div>
        </div>
      </div>

      <div class="panel log" id="log" aria-label="Match log"></div>
    </div>
  </main>
</div>

<script>
(() => {
  // ---- helpers
  const el = (id) => document.getElementById(id);
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const smooth = (t)=>t*t*(3-2*t);

  function randn() { // Box-Muller
    let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
    return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
  }
  function pickWeighted(items){
    let s = 0; for (const it of items) s += it.w;
    let r = Math.random()*s;
    for (const it of items){ r -= it.w; if (r <= 0) return it.v; }
    return items[items.length-1].v;
  }

  // ---- UI refs
  const ui = {
    aSpeed: el('aSpeed'), aSmash: el('aSmash'), aIQ: el('aIQ'),
    bSpeed: el('bSpeed'), bSmash: el('bSmash'), bIQ: el('bIQ'),
    aSpeedVal: el('aSpeedVal'), aSmashVal: el('aSmashVal'), aIQVal: el('aIQVal'),
    bSpeedVal: el('bSpeedVal'), bSmashVal: el('bSmashVal'), bIQVal: el('bIQVal'),
    play: el('play'), auto: el('auto'), reset: el('reset'),
    scoreA: el('scoreA'), scoreB: el('scoreB'),
    serveA: el('serveA'), serveB: el('serveB'),
    statusLine: el('statusLine'),
    chanceA: el('chanceA'), chanceB: el('chanceB'), chanceBar: el('chanceBar'),
    rallyLen: el('rallyLen'), endShot: el('endShot'),
    lastPoint: el('lastPoint'), reason: el('reason'),
    log: el('log'),
    cv: el('cv')
  };

  function readSkills() {
    return {
      A: { spd:+ui.aSpeed.value, sm:+ui.aSmash.value, iq:+ui.aIQ.value },
      B: { spd:+ui.bSpeed.value, sm:+ui.bSmash.value, iq:+ui.bIQ.value },
    };
  }
  function updateVals(){
    ui.aSpeedVal.textContent = ui.aSpeed.value;
    ui.aSmashVal.textContent = ui.aSmash.value;
    ui.aIQVal.textContent = ui.aIQ.value;
    ui.bSpeedVal.textContent = ui.bSpeed.value;
    ui.bSmashVal.textContent = ui.bSmash.value;
    ui.bIQVal.textContent = ui.bIQ.value;
    updateChances();
  }
  ['aSpeed','aSmash','aIQ','bSpeed','bSmash','bIQ'].forEach(id=>{
    ui[id].addEventListener('input', updateVals, {passive:true});
  });

  function addLog(html) {
    const atBottom = (ui.log.scrollTop + ui.log.clientHeight) >= (ui.log.scrollHeight - 12);
    ui.log.insertAdjacentHTML('beforeend', html);
    if (atBottom) ui.log.scrollTop = ui.log.scrollHeight;
  }

  // ---- Game rules: 21, win by 2, cap 30
  function isGameOver(a,b){
    const max = Math.max(a,b), min = Math.min(a,b);
    if (max >= 30) return true;
    if (max >= 21 && (max - min) >= 2) return true;
    return false;
  }

  // ---- Match state
  const match = {
    a: 0, b: 0,
    server: 'A', // A or B
    busy: false
  };

  function updateScoreUI(){
    ui.scoreA.textContent = match.a;
    ui.scoreB.textContent = match.b;
    ui.serveA.classList.toggle('on', match.server === 'A');
    ui.serveB.classList.toggle('on', match.server === 'B');
  }

  // ---- Skill model (more realistic flow)
  // Shot selection depends on intelligence and context (attack/defense).
  // Speed drives retrieval and defense.
  // Smash drives winners but adds error risk when overused or low IQ.
  function pointWinChance(sk){
    // A "macro" estimate for next rally (not full sim)
    const aAtk = 0.62*sk.A.sm + 0.38*sk.A.iq;
    const bAtk = 0.62*sk.B.sm + 0.38*sk.B.iq;
    const aDef = 0.58*sk.A.spd + 0.42*sk.A.iq;
    const bDef = 0.58*sk.B.spd + 0.42*sk.B.iq;

    const a = 0.55*aAtk + 0.45*aDef;
    const b = 0.55*bAtk + 0.45*bDef;

    const d = (a - b) / 17.0;
    const pA = 1 / (1 + Math.exp(-d));
    return clamp(pA, 0.08, 0.92);
  }

  function simulateRally(sk){
    // Start context: server has slight initiative advantage
    let attacker = match.server; // who is pressing at the moment
    let defender = attacker === 'A' ? 'B' : 'A';

    const get = (id)=> id==='A'? sk.A : sk.B;

    // Rally length baseline from defense & intelligence
    const defAvg = (0.60*sk.A.spd+0.40*sk.A.iq + 0.60*sk.B.spd+0.40*sk.B.iq)/2;
    const atkAvg = (0.65*sk.A.sm + 0.65*sk.B.sm)/2;
    const baseLen = clamp(5 + (defAvg-50)*0.10 - (atkAvg-50)*0.05 + randn()*1.8, 2, 26);
    const exchanges = Math.max(2, Math.round(baseLen));

    // Track some rally fatigue (minor)
    let fatigueA = 0, fatigueB = 0;

    // Determine ending event during exchanges
    let endAt = exchanges;
    let endShot = '—';
    let reason = '—';
    let winner = null;

    // Utility: probability of defender returning a shot
    function pReturn(attId, defId, shot){
      const att = get(attId), def = get(defId);
      const pace = shot === 'smash' ? lerp(0.62, 0.90, att.sm/100)
                 : shot === 'drive' ? 0.72
                 : shot === 'drop'  ? 0.55
                 : shot === 'net'   ? 0.50
                 : 0.62; // clear

      const placement = lerp(0.45, 0.78, att.iq/100); // better placement harder to return
      const defense = lerp(0.50, 0.88, (0.70*def.spd + 0.30*def.iq)/100);

      // fatigue reduces defense slightly
      const fat = defId==='A'? fatigueA : fatigueB;
      const defEff = defense * (1 - 0.18*fat);

      // return probability
      const p = clamp(defEff - 0.45*pace - 0.22*placement + 0.55, 0.05, 0.97);
      return p;
    }

    function pUnforced(attId, shot){
      const att = get(attId);
      const iq = att.iq/100;
      // smash has higher unforced risk if low IQ or very high smash
      const smashOver = clamp((att.sm - 75)/25, 0, 1);
      const base = shot === 'smash' ? (0.06 + 0.10*smashOver) : 0.03;
      const poorIQ = clamp((0.55 - iq), 0, 0.55);
      return clamp(base + 0.10*poorIQ, 0.01, 0.22);
    }

    function chooseShot(attId, defId){
      const att = get(attId);
      const def = get(defId);
      const iq = att.iq/100;
      const smash = att.sm/100;
      const defSpd = def.spd/100;

      // If attacker is strong & defender slower -> more smash/drive.
      const mismatch = clamp((smash - defSpd)*0.9, -0.5, 0.5);

      // IQ increases variety & good choice (less random smash spam).
      const smashW = lerp(0.18, 0.34, smash) + mismatch*0.12 - (1-iq)*0.10;
      const driveW = 0.22 + mismatch*0.05;
      const dropW  = 0.20 + (iq*0.10) - mismatch*0.03;
      const netW   = 0.16 + (iq*0.12) - mismatch*0.02;
      const clearW = 0.22 + (1-iq)*0.06;

      const weights = [
        {v:'smash', w: clamp(smashW, 0.08, 0.46)},
        {v:'drive', w: clamp(driveW, 0.10, 0.34)},
        {v:'drop',  w: clamp(dropW,  0.10, 0.34)},
        {v:'net',   w: clamp(netW,   0.08, 0.32)},
        {v:'clear', w: clamp(clearW, 0.10, 0.40)},
      ];
      return pickWeighted(weights);
    }

    for (let i=1;i<=exchanges;i++){
      const shot = chooseShot(attacker, defender);

      // unforced error by attacker
      if (Math.random() < pUnforced(attacker, shot)){
        endAt = i;
        endShot = shot;
        reason = 'Unforced error';
        winner = defender;
        break;
      }

      // defender returns?
      if (Math.random() > pReturn(attacker, defender, shot)){
        // winner by attacker (winner / forced error)
        endAt = i;
        endShot = shot;
        // if smash or drive -> winner, else forced error
        if (shot === 'smash' || shot === 'drive') reason = 'Winner';
        else reason = 'Forced error';
        winner = attacker;
        break;
      }

      // rally continues; small fatigue
      if (attacker === 'A') fatigueA = clamp(fatigueA + 0.018, 0, 1);
      else fatigueB = clamp(fatigueB + 0.018, 0, 1);

      // Sometimes attack switches (defender turns tables), more likely with high IQ/speed
      const def = get(defender);
      const flip = clamp(0.10 + 0.18*(def.iq/100) + 0.12*(def.spd/100), 0.08, 0.42);
      if (Math.random() < flip){
        const tmp = attacker; attacker = defender; defender = tmp;
      } else {
        // mostly alternate roles
        const tmp = attacker; attacker = defender; defender = tmp;
      }
    }

    // If no break happened, decide by slight skill edge
    if (!winner){
      const pA = pointWinChance(sk);
      winner = (Math.random() < pA) ? 'A' : 'B';
      endShot = 'drive';
      reason = 'Forced error';
      endAt = exchanges;
    }

    // Server changes only if server won rally (rally point system: winner gets point; winner serves next)
    return {
      winner,
      exchanges: endAt,
      endShot,
      reason
    };
  }

  function updateChances(){
    const sk = readSkills();
    const pA = pointWinChance(sk);
    const a = Math.round(pA*100);
    ui.chanceA.textContent = a;
    ui.chanceB.textContent = 100-a;
    ui.chanceBar.style.width = `${clamp(a, 5, 95)}%`;
  }

  // ---- Canvas rendering (court + players + shuttle)
  const ctx = ui.cv.getContext('2d', {alpha:false});

  function resizeCanvas(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const r = ui.cv.getBoundingClientRect();
    ui.cv.width = Math.floor(r.width*dpr);
    ui.cv.height = Math.floor(r.height*dpr);
  }
  window.addEventListener('resize', () => { resizeCanvas(); renderStatic(); }, {passive:true});
  resizeCanvas();

  const scene = {
    court: null,
    A: {x:0.55,y:0.84},
    B: {x:0.45,y:0.16},
    shuttle: {x:0.50,y:0.50,z:0.0},
  };

  function courtRect(){
    const w=ui.cv.width, h=ui.cv.height;
    const mx=w*0.10, my=h*0.10;
    const cw=w-2*mx, ch=h-2*my;
    const topInset=cw*0.10;
    return {w,h,mx,my,cw,ch,topInset,
      x0: mx+topInset, y0: my,
      x1: mx+cw-topInset, y1: my,
      x2: mx+cw, y2: my+ch,
      x3: mx, y3: my+ch
    };
  }
  function lerp2(a,b,t){ return {x:lerp(a.x,b.x,t), y:lerp(a.y,b.y,t)}; }
  function mapCourt(nx,ny){
    const c=scene.court;
    const topL={x:c.x0,y:c.y0}, topR={x:c.x1,y:c.y1};
    const botR={x:c.x2,y:c.y2}, botL={x:c.x3,y:c.y3};
    const left=lerp2(topL,botL,ny);
    const right=lerp2(topR,botR,ny);
    return lerp2(left,right,nx);
  }

  function drawCourt(){
    scene.court = courtRect();
    const c=scene.court;
    const w=c.w, h=c.h;

    // hall background
    const bg = ctx.createLinearGradient(0,0,0,h);
    bg.addColorStop(0,'rgb(11,15,17)');
    bg.addColorStop(1,'rgb(7,10,12)');
    ctx.fillStyle=bg;
    ctx.fillRect(0,0,w,h);

    // court polygon
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(c.x0,c.y0); ctx.lineTo(c.x1,c.y1); ctx.lineTo(c.x2,c.y2); ctx.lineTo(c.x3,c.y3);
    ctx.closePath();

    const cg = ctx.createLinearGradient(0,c.y0,0,c.y2);
    cg.addColorStop(0,'rgba(34, 150, 92, .26)');
    cg.addColorStop(1,'rgba(18, 105, 70, .20)');
    ctx.fillStyle=cg;
    ctx.fill();

    // subtle floor shine
    const shine = ctx.createRadialGradient(w*0.5,h*0.58, 10, w*0.5,h*0.58, w*0.65);
    shine.addColorStop(0,'rgba(255,255,255,.06)');
    shine.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=shine;
    ctx.fill();

    // court texture
    ctx.globalAlpha=0.20;
    ctx.strokeStyle='rgba(255,255,255,.12)';
    ctx.lineWidth=Math.max(1,w*0.0012);
    for(let i=0;i<18;i++){
      const t=i/17;
      const a=mapCourt(0.05,t), b=mapCourt(0.95,t);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.globalAlpha=1;

    // lines
    ctx.strokeStyle='rgba(235,245,255,.72)';
    ctx.lineWidth=Math.max(1.2,w*0.0018);
    ctx.lineJoin='round';

    // boundary
    ctx.beginPath();
    ctx.moveTo(c.x0,c.y0); ctx.lineTo(c.x1,c.y1); ctx.lineTo(c.x2,c.y2); ctx.lineTo(c.x3,c.y3); ctx.closePath();
    ctx.stroke();

    // center line
    ctx.globalAlpha=0.70;
    const midT=mapCourt(0.5,0), midB=mapCourt(0.5,1);
    ctx.beginPath(); ctx.moveTo(midT.x,midT.y); ctx.lineTo(midB.x,midB.y); ctx.stroke();

    // net
    ctx.globalAlpha=0.95;
    const netY=0.5, netL=mapCourt(0,netY), netR=mapCourt(1,netY);
    ctx.strokeStyle='rgba(255,255,255,.55)';
    ctx.lineWidth=Math.max(1.3,w*0.0024);
    ctx.beginPath(); ctx.moveTo(netL.x,netL.y); ctx.lineTo(netR.x,netR.y); ctx.stroke();

    // net mesh hint
    ctx.globalAlpha=0.18;
    ctx.lineWidth=Math.max(1,w*0.0010);
    for(let i=0;i<14;i++){
      const t=i/13;
      const a=lerp2(netL, netR, t);
      ctx.beginPath(); ctx.moveTo(a.x,a.y-10); ctx.lineTo(a.x,a.y+10); ctx.stroke();
    }

    ctx.restore();
  }

  function drawPlayer(nx,ny,label,active=false){
    const p=mapCourt(nx,ny);
    const r=Math.max(7, scene.court.w*0.008);
    ctx.save();
    // shadow
    ctx.globalAlpha=0.22;
    ctx.fillStyle='black';
    ctx.beginPath(); ctx.ellipse(p.x, p.y + r*0.95, r*0.95, r*0.36, 0, 0, Math.PI*2); ctx.fill();

    // body
    ctx.globalAlpha=1;
    ctx.fillStyle= active ? 'rgba(140,210,255,.92)' : 'rgba(235,245,255,.86)';
    ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();

    // label
    ctx.fillStyle='rgba(0,0,0,.65)';
    ctx.font=`${Math.max(10, scene.court.w*0.012)}px ui-sans-serif, system-ui`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(label,p.x,p.y+0.5);
    ctx.restore();
  }

  function drawShuttle(nx,ny,z,smash=false){
    const p=mapCourt(nx,ny);
    const r=Math.max(4, scene.court.w*0.0048) * (1 + z*0.10);

    ctx.save();
    if (smash){
      ctx.globalAlpha=0.22;
      ctx.fillStyle='rgba(255,255,255,.95)';
      ctx.beginPath(); ctx.arc(p.x,p.y,r*3.5,0,Math.PI*2); ctx.fill();
    }
    // shuttle head
    ctx.globalAlpha=0.95;
    ctx.fillStyle='rgba(255,255,255,.92)';
    ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
    // feathers (simple)
    ctx.globalAlpha=0.45;
    ctx.strokeStyle='rgba(255,255,255,.65)';
    ctx.lineWidth=Math.max(1, scene.court.w*0.0012);
    ctx.beginPath();
    ctx.moveTo(p.x-r*1.2, p.y-r*0.6);
    ctx.lineTo(p.x+r*1.4, p.y+r*0.5);
    ctx.stroke();
    ctx.restore();
  }

  function renderStatic(){
    drawCourt();
    drawPlayer(scene.A.x, scene.A.y, 'A', false);
    drawPlayer(scene.B.x, scene.B.y, 'B', false);
    drawShuttle(scene.shuttle.x, scene.shuttle.y, scene.shuttle.z, false);
  }

  // ---- Rally animation driven by shot list
  function planRallyAnimation(sk, outcome){
    const ex = clamp(outcome.exchanges, 2, 26);
    const smashBiasA = sk.A.sm/100;
    const smashBiasB = sk.B.sm/100;
    const speedAvg = (sk.A.spd + sk.B.spd)/2;

    // segment duration: faster players => faster pace
    const segBase = lerp(0.42, 0.22, clamp(speedAvg/100,0,1));

    function targetFor(topHitter, shot){
      // topHitter true => B hits to bottom half (A)
      // distribute targets by shot type
      let yMin,yMax,xMin=0.18,xMax=0.82;
      if (topHitter){
        // towards bottom
        if (shot==='net' || shot==='drop') { yMin=0.52; yMax=0.70; }
        else if (shot==='smash' || shot==='drive') { yMin=0.62; yMax=0.92; }
        else { yMin=0.58; yMax=0.88; } // clear
      } else {
        // towards top
        if (shot==='net' || shot==='drop') { yMin=0.30; yMax=0.48; }
        else if (shot==='smash' || shot==='drive') { yMin=0.08; yMax=0.38; }
        else { yMin=0.12; yMax=0.42; }
      }
      // sidelines a bit more often on smashes/drives
      const side = (shot==='smash'||shot==='drive') ? 0.12 : 0.06;
      xMin = 0.18 - side; xMax = 0.82 + side;
      return { x: clamp(lerp(xMin,xMax,Math.random()), 0.06, 0.94),
               y: clamp(lerp(yMin,yMax,Math.random()), 0.06, 0.94) };
    }

    // build shot plan (we don't need exact sim shot list; approximate visually)
    let cur = {x:0.50,y:0.50};
    let topHitter = (match.server === 'B'); // if B serves, first hitter top
    let plan = [];
    for (let i=0;i<ex;i++){
      const hitter = topHitter ? 'B' : 'A';
      const smashP = hitter==='A' ? lerp(0.10, 0.40, smashBiasA) : lerp(0.10, 0.40, smashBiasB);
      const shot = pickWeighted([
        {v:'smash', w: smashP},
        {v:'drive', w: 0.22},
        {v:'drop',  w: 0.18},
        {v:'net',   w: 0.14},
        {v:'clear', w: 0.22}
      ]);
      const to = targetFor(topHitter, shot);
      const dur = segBase * (shot==='smash' ? 0.70 : shot==='drive' ? 0.82 : shot==='net' ? 1.10 : 1.0);
      plan.push({from:{...cur}, to, dur, shot, hitter});
      cur = to;
      topHitter = !topHitter;
    }

    // final is decisive shot type from outcome
    if (plan.length){
      plan[plan.length-1].shot = outcome.endShot;
    }
    return plan;
  }

  async function animate(plan, outcome){
    match.busy = true;
    let idx = 0;
    let segT = 0;
    let lastTime = performance.now();

    function tick(now){
      const dt = (now - lastTime) * 0.001;
      lastTime = now;

      const seg = plan[idx];
      if (!seg){
        match.busy = false;
        renderStatic();
        return;
      }

      segT += dt;
      const t = clamp(segT / seg.dur, 0, 1);
      const e = smooth(t);

      scene.shuttle.x = lerp(seg.from.x, seg.to.x, e);
      scene.shuttle.y = lerp(seg.from.y, seg.to.y, e);
      // arc height by shot
      const arc = Math.sin(Math.PI*e);
      const arcMul = (seg.shot==='clear')? 1.35 : (seg.shot==='drop')? 0.85 : (seg.shot==='net')? 0.55 : (seg.shot==='smash')? 0.75 : 0.95;
      scene.shuttle.z = arc * 1.2 * arcMul;

      drawCourt();
      drawPlayer(scene.A.x, scene.A.y, 'A', seg.hitter==='A');
      drawPlayer(scene.B.x, scene.B.y, 'B', seg.hitter==='B');
      drawShuttle(scene.shuttle.x, scene.shuttle.y, scene.shuttle.z, seg.shot==='smash');

      if (t >= 1){
        idx++;
        segT = 0;
        if (idx >= plan.length){
          match.busy = false;
          // settle
          scene.shuttle.x = 0.50; scene.shuttle.y = 0.50; scene.shuttle.z = 0;
          renderStatic();
          return;
        }
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }

  // ---- Play one rally with rules + serve + game over
  function playOne(){
    if (match.busy) return;
    if (isGameOver(match.a, match.b)) return;

    const sk = readSkills();
    const outcome = simulateRally(sk);

    // update widgets
    ui.rallyLen.textContent = `${outcome.exchanges} exchanges`;
    ui.endShot.textContent = outcome.endShot;
    ui.reason.textContent = outcome.reason;

    // scoring
    const winner = outcome.winner;
    if (winner === 'A') match.a++; else match.b++;

    // serve: winner serves next
    match.server = winner;

    // status line + log
    ui.lastPoint.textContent = `${winner} won`;
    ui.statusLine.textContent = isGameOver(match.a, match.b)
      ? `Game over • ${match.a > match.b ? 'A' : 'B'} wins`
      : `${winner} won rally • ${winner} to serve`;

    const pillClass = (outcome.reason==='Winner') ? 'good' : (outcome.reason==='Unforced error') ? 'bad' : '';
    addLog(
      `<div>
        <span class="pill">Rally</span>
        <b>${winner}</b> won •
        <span class="muted">${outcome.exchanges} exchanges</span> •
        <span class="muted">end: ${outcome.endShot}</span> •
        <span class="pill ${pillClass}">${outcome.reason}</span>
      </div>`
    );

    updateScoreUI();
    updateChances();

    // animate
    const plan = planRallyAnimation(sk, outcome);
    animate(plan, outcome);
  }

  async function auto(n=10){
    if (match.busy) return;
    for (let i=0;i<n;i++){
      if (isGameOver(match.a, match.b)) break;
      playOne();
      await waitUntil(() => !match.busy, 7000);
      await sleep(120);
    }
  }

  function reset(){
    match.a = 0; match.b = 0;
    match.server = 'A';
    match.busy = false;

    ui.statusLine.textContent = 'Ready';
    ui.rallyLen.textContent = '—';
    ui.endShot.textContent = '—';
    ui.lastPoint.textContent = '—';
    ui.reason.textContent = '—';

    ui.log.innerHTML = `<div class="muted">Set skills, then press <b>Play rally</b>. Rules: 21 points, win by 2, cap 30.</div>`;
    updateScoreUI();
    updateChances();

    scene.A.x = 0.55; scene.A.y = 0.84;
    scene.B.x = 0.45; scene.B.y = 0.16;
    scene.shuttle.x = 0.50; scene.shuttle.y = 0.50; scene.shuttle.z = 0;
    renderStatic();
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function waitUntil(pred, timeoutMs){
    const start = performance.now();
    return new Promise((resolve)=>{
      (function loop(){
        if (pred()) return resolve(true);
        if (performance.now() - start > timeoutMs) return resolve(false);
        requestAnimationFrame(loop);
      })();
    });
  }

  ui.play.addEventListener('click', playOne);
  ui.auto.addEventListener('click', () => auto(10));
  ui.reset.addEventListener('click', reset);

  // init
  updateVals();
  reset();
})();
</script>
</body>
</html>
