<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Badminton sim</title>
  <style>
    :root{
      --bg:#0f1418;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.04);
      --stroke: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --good: rgba(120, 220, 160, .85);
      --bad: rgba(255, 140, 140, .85);
      --accent: rgba(140, 210, 255, .9);
      --shadow: rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1100px 700px at 30% 10%, rgba(140,210,255,.10), transparent 55%),
                  radial-gradient(900px 600px at 75% 30%, rgba(120,220,160,.06), transparent 60%),
                  linear-gradient(180deg, #0b1013, var(--bg));
      color:var(--text);
      overflow:hidden;
    }
    #app{height:100%; display:flex; flex-direction:column;}
    header{
      padding:14px 14px 10px;
      display:flex; gap:12px; align-items:flex-end; justify-content:space-between;
      z-index:3; position:relative;
    }
    .title h1{margin:0; font-size:16px; font-weight:650; letter-spacing:.2px}
    .title p{margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.35; max-width:560px}
    .panel{
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid var(--stroke);
      border-radius:14px;
      box-shadow: 0 14px 45px var(--shadow), inset 0 1px 0 rgba(255,255,255,.06);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .controls{
      width:min(520px, calc(100vw - 28px));
      padding:12px 12px 10px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .slot{
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.12);
    }
    .slot h3{
      margin:0 0 8px;
      font-size:12px;
      font-weight:650;
      color: rgba(255,255,255,.86);
      letter-spacing:.2px;
    }
    .row{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin:8px 0;}
    label{display:flex; flex-direction:column; gap:4px; font-size:12px; color:var(--muted);}
    input[type="range"]{width:100%; appearance:none; height:18px; background: transparent; outline:none;}
    input[type="range"]::-webkit-slider-runnable-track{
      height:8px; border-radius:999px;
      background: linear-gradient(90deg, rgba(140,210,255,.22), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    input[type="range"]::-webkit-slider-thumb{
      appearance:none; width:18px; height:18px; border-radius:50%; margin-top:-6px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.92), rgba(140,210,255,.55));
      border:1px solid rgba(255,255,255,.25);
      box-shadow: 0 8px 20px rgba(0,0,0,.35), 0 0 0 4px rgba(140,210,255,.10);
    }
    input[type="range"]::-moz-range-track{
      height:8px; border-radius:999px;
      background: linear-gradient(90deg, rgba(140,210,255,.22), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.08);
    }
    input[type="range"]::-moz-range-thumb{
      width:18px; height:18px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.92), rgba(140,210,255,.55));
      border:1px solid rgba(255,255,255,.25);
      box-shadow: 0 8px 20px rgba(0,0,0,.35), 0 0 0 4px rgba(140,210,255,.10);
    }
    .val{
      min-width:56px;
      text-align:right;
      font-size:12px;
      font-variant-numeric: tabular-nums;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.10);
      color: rgba(255,255,255,.84);
      user-select:none;
    }
    .buttons{
      display:flex;
      gap:10px;
      margin-top:10px;
    }
    button{
      flex:1;
      cursor:pointer;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.90);
      padding:10px 10px;
      font-size:12px;
      letter-spacing:.2px;
      box-shadow: 0 10px 28px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.06);
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    button:hover{ background: rgba(255,255,255,.06); border-color: rgba(140,210,255,.22); }
    button:active{ transform: translateY(1px); }

    main{
      position:relative;
      flex:1;
      padding: 0 14px 14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      z-index:2;
    }
    .stage{
      position:relative;
      overflow:hidden;
      height: min(62vh, 560px);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 14px 60px rgba(0,0,0,.35);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.08));
    }
    canvas{position:absolute; inset:0; width:100%; height:100%;}
    .overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(900px 500px at 50% -10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(900px 600px at 50% 120%, rgba(0,0,0,.40), transparent 65%),
        radial-gradient(1200px 900px at 50% 50%, transparent 60%, rgba(0,0,0,.35));
      opacity:.95;
      mix-blend-mode: screen;
    }

    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      padding:10px;
    }
    .stat{
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.12);
    }
    .stat .k{font-size:11px; color:var(--muted); margin-bottom:6px;}
    .stat .v{font-size:14px; font-variant-numeric: tabular-nums; letter-spacing:.2px;}
    .bar{
      height:8px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      overflow:hidden;
      margin-top:8px;
    }
    .bar > i{
      display:block;
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(140,210,255,.65), rgba(120,220,160,.55));
    }

    .log{
      padding:10px 12px;
      height: 150px;
      overflow:auto;
      font-size:12px;
      line-height:1.35;
      color: rgba(255,255,255,.84);
    }
    .log .muted{color:var(--muted)}
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      margin-right:6px;
      font-size:11px;
      color: rgba(255,255,255,.78);
    }

    @media (max-width: 920px){
      header{flex-direction:column; align-items:stretch;}
      .grid{grid-template-columns:1fr;}
      .stats{grid-template-columns:1fr;}
      .stage{height: min(58vh, 520px);}
    }
  </style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">
      <h1>Badminton sim</h1>
      <p>Match simulator using player skills. Adjust Speed, Smash Power, and Intelligence for both players, then run rallies to see outcomes.</p>
    </div>

    <div class="panel controls" role="region" aria-label="Controls">
      <div class="grid">
        <div class="slot">
          <h3>Player A</h3>
          <div class="row">
            <label>Speed
              <input id="aSpeed" type="range" min="0" max="100" step="1" value="65">
            </label>
            <div class="val" id="aSpeedVal">65</div>
          </div>
          <div class="row">
            <label>Smash power
              <input id="aSmash" type="range" min="0" max="100" step="1" value="62">
            </label>
            <div class="val" id="aSmashVal">62</div>
          </div>
          <div class="row">
            <label>Intelligence
              <input id="aIQ" type="range" min="0" max="100" step="1" value="58">
            </label>
            <div class="val" id="aIQVal">58</div>
          </div>
        </div>

        <div class="slot">
          <h3>Player B</h3>
          <div class="row">
            <label>Speed
              <input id="bSpeed" type="range" min="0" max="100" step="1" value="60">
            </label>
            <div class="val" id="bSpeedVal">60</div>
          </div>
          <div class="row">
            <label>Smash power
              <input id="bSmash" type="range" min="0" max="100" step="1" value="66">
            </label>
            <div class="val" id="bSmashVal">66</div>
          </div>
          <div class="row">
            <label>Intelligence
              <input id="bIQ" type="range" min="0" max="100" step="1" value="55">
            </label>
            <div class="val" id="bIQVal">55</div>
          </div>
        </div>
      </div>

      <div class="buttons">
        <button id="play">Play point</button>
        <button id="auto">Auto (10 pts)</button>
        <button id="reset">Reset</button>
      </div>
    </div>
  </header>

  <main>
    <div class="stage panel">
      <canvas id="cv"></canvas>
      <div class="overlay"></div>
    </div>

    <div class="panel stats">
      <div class="stat">
        <div class="k">Score</div>
        <div class="v"><span id="scoreA">0</span> - <span id="scoreB">0</span></div>
        <div class="bar" aria-hidden="true"><i id="scoreBar"></i></div>
      </div>
      <div class="stat">
        <div class="k">Win chance (next point)</div>
        <div class="v"><span id="chanceA">50</span>% / <span id="chanceB">50</span>%</div>
        <div class="bar" aria-hidden="true"><i id="chanceBar"></i></div>
      </div>
      <div class="stat">
        <div class="k">Last point</div>
        <div class="v" id="lastPoint">—</div>
        <div class="k" style="margin-top:8px;"><span class="pill" id="rallyLen">Rally: —</span><span class="pill" id="reason">Reason: —</span></div>
      </div>
    </div>

    <div class="panel log" id="log" aria-label="Match log"></div>
  </main>
</div>

<script>
(() => {
  // ----- UI
  const el = (id) => document.getElementById(id);
  const ui = {
    aSpeed: el('aSpeed'), aSmash: el('aSmash'), aIQ: el('aIQ'),
    bSpeed: el('bSpeed'), bSmash: el('bSmash'), bIQ: el('bIQ'),
    aSpeedVal: el('aSpeedVal'), aSmashVal: el('aSmashVal'), aIQVal: el('aIQVal'),
    bSpeedVal: el('bSpeedVal'), bSmashVal: el('bSmashVal'), bIQVal: el('bIQVal'),
    play: el('play'), auto: el('auto'), reset: el('reset'),
    scoreA: el('scoreA'), scoreB: el('scoreB'),
    chanceA: el('chanceA'), chanceB: el('chanceB'),
    lastPoint: el('lastPoint'),
    rallyLen: el('rallyLen'),
    reason: el('reason'),
    scoreBar: el('scoreBar'),
    chanceBar: el('chanceBar'),
    log: el('log'),
    cv: el('cv')
  };

  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function readSkills() {
    return {
      A: { spd:+ui.aSpeed.value, sm:+ui.aSmash.value, iq:+ui.aIQ.value },
      B: { spd:+ui.bSpeed.value, sm:+ui.bSmash.value, iq:+ui.bIQ.value },
    };
  }
  function updateVals(){
    ui.aSpeedVal.textContent = ui.aSpeed.value;
    ui.aSmashVal.textContent = ui.aSmash.value;
    ui.aIQVal.textContent = ui.aIQ.value;
    ui.bSpeedVal.textContent = ui.bSpeed.value;
    ui.bSmashVal.textContent = ui.bSmash.value;
    ui.bIQVal.textContent = ui.bIQ.value;
    updateChances();
  }
  ['aSpeed','aSmash','aIQ','bSpeed','bSmash','bIQ'].forEach(id=>{
    ui[id].addEventListener('input', updateVals, {passive:true});
  });

  // ----- Match state
  const match = {
    scoreA: 0,
    scoreB: 0,
    last: null,
    anim: null,
    busy: false
  };

  // ----- Simple but realistic-ish point model
  // Each rally consists of exchanges. Probability shifts based on:
  // - Speed: court coverage & defense
  // - Intelligence: shot selection & error avoidance
  // - Smash: kill potential but also slightly increases error at high levels
  //
  // This is not physics-accurate badminton; it's a skills-based simulator with sensible dynamics.
  function pointWinChance(sk) {
    // build an "effective strength" for each player
    // weights tuned for balanced outcomes
    const eff = (p) => {
      const smashRisk = 0.12 * Math.pow(clamp((p.sm - 70)/30, 0, 1), 1.4); // big smash -> more risk
      const attack = 0.50*p.sm + 0.25*p.iq + 0.25*p.spd;
      const defense= 0.45*p.spd + 0.40*p.iq + 0.15*(100-p.sm*0.25);
      const base = 0.58*attack + 0.42*defense;
      return base * (1 - smashRisk);
    };
    const a = eff(sk.A);
    const b = eff(sk.B);
    // logistic transform to probability
    const d = (a - b) / 18.0;
    const pA = 1 / (1 + Math.exp(-d));
    return clamp(pA, 0.05, 0.95);
  }

  function simulatePoint(sk) {
    const pA0 = pointWinChance(sk);

    // rally length influenced by defense (speed+iq) and attack imbalance
    const defA = 0.55*sk.A.spd + 0.45*sk.A.iq;
    const defB = 0.55*sk.B.spd + 0.45*sk.B.iq;
    const atkA = 0.65*sk.A.sm  + 0.35*sk.A.iq;
    const atkB = 0.65*sk.B.sm  + 0.35*sk.B.iq;

    const defense = (defA + defB)/2;
    const attack  = (atkA + atkB)/2;
    const imbalance = Math.abs(atkA - atkB) * 0.25 + Math.abs(defA - defB) * 0.15;

    const expected = clamp(6 + (defense-50)*0.10 - (attack-50)*0.06 - imbalance*0.04, 3, 20);
    const rally = Math.max(1, Math.round(expected + randn()*2.2));

    // Determine end reason
    // More smash => more winners and also more out/into net at extremes
    const smashAgg = (sk.A.sm + sk.B.sm)/2;
    const errBias = clamp((smashAgg - 55)/55, 0, 1); // higher smash => more decisive points
    const winnerBias = clamp((smashAgg - 45)/65, 0, 1);

    // Sample winner using pA0 slightly nudged by intelligence when rally is long
    const longRally = clamp((rally - 6)/14, 0, 1);
    const iqEdge = (sk.A.iq - sk.B.iq) / 220; // small
    const pA = clamp(pA0 + longRally * iqEdge, 0.05, 0.95);

    const winA = Math.random() < pA;

    // Reason
    const r = Math.random();
    let reason;
    if (r < 0.30 + 0.25*winnerBias) {
      reason = "Winner (smash/kill)";
    } else if (r < 0.62 + 0.18*errBias) {
      reason = "Forced error";
    } else {
      reason = "Unforced error";
    }

    // If low intelligence, increase unforced error probability
    const avgIQ = (sk.A.iq + sk.B.iq)/2;
    if (Math.random() < clamp((55 - avgIQ)/120, 0, 0.20)) reason = "Unforced error";

    return { winA, rally, reason, pA };
  }

  function randn() {
    // Box-Muller
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }

  function updateScoreUI() {
    ui.scoreA.textContent = match.scoreA;
    ui.scoreB.textContent = match.scoreB;

    const total = match.scoreA + match.scoreB;
    const fracA = total === 0 ? 0.5 : match.scoreA / total;
    ui.scoreBar.style.width = `${clamp(fracA*100, 5, 95)}%`;
  }

  function addLog(html) {
    const atBottom = (ui.log.scrollTop + ui.log.clientHeight) >= (ui.log.scrollHeight - 12);
    ui.log.insertAdjacentHTML('beforeend', html);
    if (atBottom) ui.log.scrollTop = ui.log.scrollHeight;
  }

  function updateChances() {
    const sk = readSkills();
    const pA = pointWinChance(sk);
    const a = Math.round(pA*100);
    const b = 100 - a;
    ui.chanceA.textContent = a;
    ui.chanceB.textContent = b;
    ui.chanceBar.style.width = `${clamp(a, 5, 95)}%`;
  }

  // ----- Court visualization (simple + realistic layout)
  const ctx = ui.cv.getContext('2d', { alpha:false });
  function resizeCanvas() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const rect = ui.cv.getBoundingClientRect();
    ui.cv.width = Math.floor(rect.width * dpr);
    ui.cv.height = Math.floor(rect.height * dpr);
  }
  window.addEventListener('resize', () => { resizeCanvas(); }, {passive:true});
  resizeCanvas();

  // Scene coordinates in "court space"
  const scene = {
    // normalized court bounds in screen px computed per frame
    w: 0, h: 0,
    court: null,
    // positions (0..1 in court length), A bottom side, B top side
    A: { x: 0.55, y: 0.82 },
    B: { x: 0.45, y: 0.18 },
    shuttle: { x: 0.50, y: 0.50, z: 0.0, vx:0, vy:0, vz:0 },
  };

  function courtRect() {
    const w = ui.cv.width, h = ui.cv.height;
    scene.w = w; scene.h = h;
    const marginX = w * 0.12;
    const marginY = h * 0.10;
    const cw = w - 2*marginX;
    const ch = h - 2*marginY;
    // Slight perspective (top narrower)
    const topInset = cw * 0.08;
    return {
      x0: marginX + topInset, y0: marginY,
      x1: marginX + cw - topInset, y1: marginY,
      x2: marginX + cw, y2: marginY + ch,
      x3: marginX, y3: marginY + ch,
      // helper
      marginX, marginY, cw, ch, topInset
    };
  }

  function lerp2(a,b,t){ return {x:lerp(a.x,b.x,t), y:lerp(a.y,b.y,t)}; }
  function mapCourt(nx, ny) {
    // Bilinear mapping within trapezoid (top edge smaller)
    const c = scene.court;
    const topL = {x:c.x0, y:c.y0}, topR = {x:c.x1, y:c.y1};
    const botR = {x:c.x2, y:c.y2}, botL = {x:c.x3, y:c.y3};
    const left  = lerp2(topL, botL, ny);
    const right = lerp2(topR, botR, ny);
    return lerp2(left, right, nx);
  }

  function drawCourt() {
    scene.court = courtRect();
    const c = scene.court;
    const w = scene.w, h = scene.h;

    // Background (hall)
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgb(12,16,18)');
    g.addColorStop(1, 'rgb(8,12,14)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // Court surface
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(c.x0,c.y0); ctx.lineTo(c.x1,c.y1); ctx.lineTo(c.x2,c.y2); ctx.lineTo(c.x3,c.y3);
    ctx.closePath();
    const cg = ctx.createLinearGradient(0,c.y0,0,c.y2);
    cg.addColorStop(0, 'rgba(35, 150, 90, .22)');
    cg.addColorStop(1, 'rgba(20, 110, 70, .18)');
    ctx.fillStyle = cg;
    ctx.fill();

    // Subtle texture lines
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = 'rgba(255,255,255,.12)';
    ctx.lineWidth = Math.max(1, w * 0.0012);
    for (let i=0;i<18;i++){
      const t = i/17;
      const a = mapCourt(0.05, t);
      const b = mapCourt(0.95, t);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Court lines
    ctx.strokeStyle = 'rgba(235,245,255,.70)';
    ctx.lineWidth = Math.max(1.2, w * 0.0016);
    ctx.lineJoin = 'round';

    // Outer boundary
    ctx.beginPath();
    ctx.moveTo(c.x0,c.y0); ctx.lineTo(c.x1,c.y1); ctx.lineTo(c.x2,c.y2); ctx.lineTo(c.x3,c.y3); ctx.closePath();
    ctx.stroke();

    // Center line + service lines (approx)
    const midTop = mapCourt(0.50, 0.00);
    const midBot = mapCourt(0.50, 1.00);
    ctx.globalAlpha = 0.75;
    ctx.beginPath(); ctx.moveTo(midTop.x, midTop.y); ctx.lineTo(midBot.x, midBot.y); ctx.stroke();

    const netY = 0.50;
    const netL = mapCourt(0.00, netY);
    const netR = mapCourt(1.00, netY);
    ctx.globalAlpha = 0.95;
    ctx.strokeStyle = 'rgba(255,255,255,.55)';
    ctx.lineWidth = Math.max(1.2, w * 0.0022);
    ctx.beginPath(); ctx.moveTo(netL.x, netL.y); ctx.lineTo(netR.x, netR.y); ctx.stroke();

    // Short service lines
    ctx.globalAlpha = 0.65;
    ctx.lineWidth = Math.max(1.0, w * 0.0014);
    const ss1 = mapCourt(0.00, 0.34), ss2 = mapCourt(1.00, 0.34);
    const ss3 = mapCourt(0.00, 0.66), ss4 = mapCourt(1.00, 0.66);
    ctx.beginPath(); ctx.moveTo(ss1.x, ss1.y); ctx.lineTo(ss2.x, ss2.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ss3.x, ss3.y); ctx.lineTo(ss4.x, ss4.y); ctx.stroke();

    ctx.restore();
  }

  function drawPlayer(nx, ny, label, highlight=0) {
    const p = mapCourt(nx, ny);
    const r = Math.max(7, scene.w * 0.008);
    ctx.save();
    // shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = 'black';
    ctx.beginPath(); ctx.ellipse(p.x, p.y + r*0.9, r*0.9, r*0.35, 0, 0, Math.PI*2); ctx.fill();
    // body
    ctx.globalAlpha = 1;
    ctx.fillStyle = highlight ? 'rgba(140,210,255,.90)' : 'rgba(235,245,255,.85)';
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    // label
    ctx.fillStyle = 'rgba(0,0,0,.65)';
    ctx.font = `${Math.max(10, scene.w*0.012)}px ui-sans-serif, system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, p.x, p.y+0.5);
    ctx.restore();
  }

  function drawShuttle(nx, ny, z, glow=0.0) {
    const p = mapCourt(nx, ny);
    const r = Math.max(4, scene.w * 0.0045) * (1 + z*0.12);
    ctx.save();
    // glow
    if (glow > 0) {
      ctx.globalAlpha = 0.20 + glow*0.35;
      ctx.fillStyle = 'rgba(255,255,255,.95)';
      ctx.beginPath(); ctx.arc(p.x, p.y, r*3.2, 0, Math.PI*2); ctx.fill();
    }
    // shuttle (simple)
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = 'rgba(255,255,255,.92)';
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.45;
    ctx.strokeStyle = 'rgba(255,255,255,.65)';
    ctx.lineWidth = Math.max(1, scene.w*0.0012);
    ctx.beginPath();
    ctx.moveTo(p.x-r*1.2, p.y-r*0.6);
    ctx.lineTo(p.x+r*1.3, p.y+r*0.5);
    ctx.stroke();
    ctx.restore();
  }

  function renderFrame(highlightA=0, highlightB=0, shuttleGlow=0) {
    drawCourt();
    drawPlayer(scene.A.x, scene.A.y, 'A', highlightA);
    drawPlayer(scene.B.x, scene.B.y, 'B', highlightB);
    drawShuttle(scene.shuttle.x, scene.shuttle.y, scene.shuttle.z, shuttleGlow);
  }

  // ----- Animation helpers
  function animateRally(sk, simResult) {
    // Create a simple rally animation: shuttle travels between players (top/bottom)
    // Rally length affects number of exchanges. Smash increases speed and glow.
    const exchanges = clamp(simResult.rally, 2, 20);
    const smashAvg = (sk.A.sm + sk.B.sm)/2;
    const speedAvg = (sk.A.spd + sk.B.spd)/2;

    // Timing: higher speed => shorter segments, longer rally => more segments
    const baseSeg = lerp(0.42, 0.22, clamp(speedAvg/100, 0, 1));
    const segDur = clamp(baseSeg * lerp(1.05, 0.85, clamp(smashAvg/100,0,1)), 0.16, 0.55);

    // Random target points (realistic-ish placement)
    function targetFor(sideTop){
      // sideTop: true means B hits towards A half (bottom), else A hits towards B (top)
      const y = sideTop ? lerp(0.62, 0.92, Math.random()) : lerp(0.08, 0.38, Math.random());
      const x = lerp(0.18, 0.82, Math.random());
      return {x,y};
    }

    // Start from server side (random)
    let fromTop = Math.random() < 0.5; // who hits first
    let cur = {x:scene.shuttle.x, y:scene.shuttle.y};
    let plan = [];
    for (let i=0;i<exchanges;i++){
      const nxt = targetFor(fromTop);
      const isSmash = Math.random() < lerp(0.10, 0.38, clamp(smashAvg/100,0,1));
      plan.push({ from:{...cur}, to:nxt, dur: segDur * (isSmash ? 0.75 : 1.0), smash:isSmash, hitterTop: fromTop });
      cur = nxt;
      fromTop = !fromTop;
    }

    // Final: point ends. Winner hits last "decisive" shot (if winnerBias)
    const winA = simResult.winA;
    const lastHitterTop = plan.length ? plan[plan.length-1].hitterTop : false;
    const winnerIsTop = winA ? false : true; // A bottom => not top; B top => top
    // If winner isn't last hitter in plan, add one more decisive shot
    if (plan.length && lastHitterTop !== winnerIsTop){
      const nxt = targetFor(winnerIsTop);
      plan.push({ from:{...cur}, to:nxt, dur: segDur*0.70, smash:true, hitterTop: winnerIsTop });
    }

    match.busy = true;
    let segIndex = 0;
    let segT = 0;

    const start = performance.now();
    let lastTime = start;

    function tick(now){
      const dt = (now - lastTime) * 0.001;
      lastTime = now;

      const seg = plan[segIndex];
      if (!seg){
        match.busy = false;
        return;
      }

      segT += dt;
      const t = clamp(segT / seg.dur, 0, 1);
      const ease = t*t*(3-2*t);

      scene.shuttle.x = lerp(seg.from.x, seg.to.x, ease);
      scene.shuttle.y = lerp(seg.from.y, seg.to.y, ease);
      // pseudo "arc"
      const arc = Math.sin(Math.PI * ease);
      const arcHeight = seg.smash ? 0.7 : 1.0;
      scene.shuttle.z = arc * 1.2 * arcHeight;

      // hitter highlight
      const hA = seg.hitterTop ? 0 : 1;
      const hB = seg.hitterTop ? 1 : 0;
      const glow = seg.smash ? 0.8 : 0.25;

      renderFrame(hA, hB, glow);

      if (t >= 1){
        segIndex++;
        segT = 0;
        // tiny settle at end
        if (segIndex >= plan.length){
          // settle shuttle near net
          scene.shuttle.x = 0.50;
          scene.shuttle.y = 0.50;
          scene.shuttle.z = 0;
          renderFrame(0,0,0);
          match.busy = false;
          return;
        }
      }
      requestAnimationFrame(tick);
    }

    requestAnimationFrame(tick);
  }

  // ----- Point play
  function playOnePoint() {
    if (match.busy) return;

    const sk = readSkills();
    const res = simulatePoint(sk);

    // Update UI meta
    ui.rallyLen.textContent = `Rally: ${res.rally}`;
    ui.reason.textContent = `Reason: ${res.reason}`;

    const winner = res.winA ? 'A' : 'B';
    ui.lastPoint.textContent = `${winner} won`;

    // Score
    if (res.winA) match.scoreA++; else match.scoreB++;
    updateScoreUI();

    // Log
    const pA = Math.round(res.pA*100);
    const line = `<div><span class="pill">Point</span><b>${winner}</b> won • rally <b>${res.rally}</b> • <span class="muted">${res.reason}</span> • <span class="muted">win chance A ${pA}%</span></div>`;
    addLog(line);

    // Animate
    animateRally(sk, res);

    // Refresh next-point chance after slight delay (so it feels responsive)
    setTimeout(updateChances, 80);
  }

  async function autoPoints(n=10) {
    if (match.busy) return;
    for (let i=0;i<n;i++){
      playOnePoint();
      // wait until animation finished
      await waitUntil(() => !match.busy, 6000);
      await sleep(120);
    }
  }

  function resetMatch(){
    match.scoreA = 0; match.scoreB = 0;
    ui.lastPoint.textContent = '—';
    ui.rallyLen.textContent = 'Rally: —';
    ui.reason.textContent = 'Reason: —';
    ui.log.innerHTML = `<div class="muted">Adjust skills, then press <b>Play point</b>.</div>`;
    updateScoreUI();
    updateChances();
    scene.A.x = 0.55; scene.A.y = 0.82;
    scene.B.x = 0.45; scene.B.y = 0.18;
    scene.shuttle.x = 0.50; scene.shuttle.y = 0.50; scene.shuttle.z = 0;
    renderFrame(0,0,0);
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function waitUntil(pred, timeoutMs){
    const start = performance.now();
    return new Promise((resolve)=>{
      (function loop(){
        if (pred()) return resolve(true);
        if (performance.now() - start > timeoutMs) return resolve(false);
        requestAnimationFrame(loop);
      })();
    });
  }

  ui.play.addEventListener('click', playOnePoint);
  ui.auto.addEventListener('click', () => autoPoints(10));
  ui.reset.addEventListener('click', resetMatch);

  // Init
  updateVals();
  resetMatch();

  // Render loop fallback (keeps court crisp on resize)
  let lastW = 0, lastH = 0;
  function idle() {
    const w = ui.cv.width, h = ui.cv.height;
    if (w !== lastW || h !== lastH) {
      lastW = w; lastH = h;
      renderFrame(0,0,0);
    }
    requestAnimationFrame(idle);
  }
  requestAnimationFrame(idle);
})();
</script>
</body>
</html>
